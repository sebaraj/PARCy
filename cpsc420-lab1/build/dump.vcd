$date
	Sat Jan 25 14:55:17 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module imuldiv_MulDivReqMsgFromBits $end
$var wire 67 ! bits [66:0] $end
$var wire 3 " func [2:0] $end
$var wire 32 # b [31:0] $end
$var wire 32 $ a [31:0] $end
$upscope $end
$scope module imuldiv_MulDivReqMsgToBits $end
$var wire 32 % a [31:0] $end
$var wire 32 & b [31:0] $end
$var wire 3 ' func [2:0] $end
$var wire 67 ( bits [66:0] $end
$upscope $end
$scope module imuldiv_MulDivReqMsgToStr $end
$var wire 67 ) msg [66:0] $end
$var wire 3 * func [2:0] $end
$var wire 32 + b [31:0] $end
$var wire 32 , a [31:0] $end
$var parameter 3 - div $end
$var parameter 3 . divu $end
$var parameter 3 / mul $end
$var parameter 3 0 rem $end
$var parameter 3 1 remu $end
$var reg 160 2 full_str [159:0] $end
$var reg 16 3 tiny_str [15:0] $end
$upscope $end
$scope module sim $end
$var wire 1 4 muldivreq_go $end
$var wire 1 5 muldivresp_go $end
$var wire 1 6 sink_rdy $end
$var wire 1 7 src_rdy $end
$var wire 1 8 sink_val $end
$var wire 32 9 sink_msg [31:0] $end
$var reg 1 : busy $end
$var reg 1 ; clk $end
$var reg 32 < cycle_count [31:0] $end
$var reg 1024 = op_type [1023:0] $end
$var reg 1 > reset $end
$var reg 32 ? src_msg_a [31:0] $end
$var reg 32 @ src_msg_b [31:0] $end
$var reg 3 A src_msg_fn [2:0] $end
$var reg 1 B src_val $end
$scope module imuldiv $end
$var wire 1 ; clk $end
$var wire 1 C is_result_signed_divmul $end
$var wire 1 D is_result_signed_rem $end
$var wire 32 E muldivreq_msg_a [31:0] $end
$var wire 32 F muldivreq_msg_b [31:0] $end
$var wire 3 G muldivreq_msg_fn [2:0] $end
$var wire 1 7 muldivreq_rdy $end
$var wire 1 B muldivreq_val $end
$var wire 1 6 muldivresp_rdy $end
$var wire 1 > reset $end
$var wire 32 H unsigned_result [31:0] $end
$var wire 32 I unsigned_b [31:0] $end
$var wire 32 J unsigned_a [31:0] $end
$var wire 1 K sign_bit_b $end
$var wire 1 L sign_bit_a $end
$var wire 1 8 muldivresp_val $end
$var wire 32 M muldivresp_msg_result [31:0] $end
$var wire 1 N is_result_signed $end
$var reg 64 O a_reg [63:0] $end
$var reg 32 P b_reg [31:0] $end
$var reg 3 Q fn_reg [2:0] $end
$var reg 1 8 val_reg $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100 1
b11 0
b0 /
b10 .
b1 -
$end
#0
$dumpvars
bx Q
bx P
bx O
xN
bx M
xL
xK
bx J
bx I
bx H
bx G
bx F
bx E
xD
xC
0B
bx A
bx @
bx ?
1>
bx =
b0 <
0;
0:
bx 9
x8
17
16
x5
04
b11111100111111 3
b111010101101110011001000110010101100110011010010110111001100101011001000010000001100110011101010110111001100011 2
bz ,
bz +
bz *
bz )
bz (
bz '
bz &
bz %
bz $
bz #
bz "
bz !
$end
#5
05
08
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx O
1;
#10
14
0;
1B
b11111111111111111111111111111111 @
b11111111111111111111111111111111 F
b11111110 ?
b11111110 E
b0 A
b0 G
b11011010111010101101100 =
0>
#15
b11111111111111111111111100000010 9
b11111111111111111111111100000010 M
b11111110 H
1N
1C
b11111110 J
04
15
1K
b1 I
0D
0L
b1 <
0B
1:
18
b11111111111111111111111111111111 P
b11111110 O
b0 Q
1;
#20
0;
#25
05
08
1;
